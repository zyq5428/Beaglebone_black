From 5b39408cb183cb4e8628822dac8bd78675e12f2d Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Fri, 11 Aug 2017 15:42:15 -0500
Subject: [PATCH] beagle_x15: uEnv.txt, bootz, n fixes

Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 Makefile                                  |   2 +-
 arch/arm/dts/Makefile                     |   2 +
 arch/arm/dts/am571x-sndrblock-common.dtsi | 603 ++++++++++++++++++++++++++++++
 arch/arm/dts/am571x-sndrblock.dts         | 119 ++++++
 arch/arm/dts/am57xx-beagle-x15-revc.dts   |  24 ++
 board/ti/am57xx/board.c                   |  82 +++-
 configs/am57xx_evm_defconfig              |   8 +-
 include/configs/ti_armv7_common.h         | 347 +++++++++++++++++
 include/configs/ti_omap5_common.h         |  40 +-
 include/environment/ti/mmc.h              |  45 ++-
 scripts/Kbuild.include                    |   5 +
 scripts/Makefile.extrawarn                |   6 +
 12 files changed, 1244 insertions(+), 39 deletions(-)
 create mode 100644 arch/arm/dts/am571x-sndrblock-common.dtsi
 create mode 100644 arch/arm/dts/am571x-sndrblock.dts
 create mode 100644 arch/arm/dts/am57xx-beagle-x15-revc.dts

diff --git a/Makefile b/Makefile
index 9217a83fe5..49dc0a3665 100644
--- a/Makefile
+++ b/Makefile
@@ -371,7 +371,7 @@ export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
 export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
 export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
 export MAKE AWK PERL PYTHON
-export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS
+export HOSTCXX HOSTCXXFLAGS CHECK CHECKFLAGS DTC DTC_FLAGS
 
 export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
 export KBUILD_CFLAGS KBUILD_AFLAGS
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index e8c97e5a90..cb14851997 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -143,6 +143,8 @@ dtb-$(CONFIG_TARGET_DRA7XX_EVM) += dra72-evm.dtb dra7-evm.dtb	\
 	dra72-evm-revc.dtb dra71-evm.dtb
 dtb-$(CONFIG_TARGET_AM57XX_EVM) += am57xx-beagle-x15.dtb \
 	am57xx-beagle-x15-revb1.dtb \
+	am57xx-beagle-x15-revc.dtb \
+	am571x-sndrblock.dtb	\
 	am57xx-evm-reva3.dtb \
 	am572x-idk.dtb	\
 	am571x-idk.dtb
diff --git a/arch/arm/dts/am571x-sndrblock-common.dtsi b/arch/arm/dts/am571x-sndrblock-common.dtsi
new file mode 100644
index 0000000000..a8046cd127
--- /dev/null
+++ b/arch/arm/dts/am571x-sndrblock-common.dtsi
@@ -0,0 +1,603 @@
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "dra72x.dtsi"
+#include "am57xx-commercial-grade.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	compatible = "ti,am571x-sndrblock", "ti,am5718", "ti,dra722", "ti,dra72", "ti,dra7";
+
+	chosen {
+		stdout-path = &uart3;
+	};
+
+	aliases {
+		rtc0 = &mcp_rtc;
+		rtc1 = &tps659038_rtc;
+		rtc2 = &rtc;
+		display0 = &hdmi0;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x80000000>;
+	};
+
+	vdd_3v3: fixedregulator-vdd_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_3v3";
+		vin-supply = <&regen1>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	aic_dvdd: fixedregulator-aic_dvdd {
+		compatible = "regulator-fixed";
+		regulator-name = "aic_dvdd_fixed";
+		vin-supply = <&vdd_3v3>;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	vtt_fixed: fixedregulator-vtt {
+		/* TPS51200 */
+		compatible = "regulator-fixed";
+		regulator-name = "vtt_fixed";
+		vin-supply = <&smps3_reg>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		gpio = <&gpio7 11 GPIO_ACTIVE_HIGH>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led0 {
+			label = "sndrBlock:usr0";
+			gpios = <&gpio7 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+
+		led1 {
+			label = "sndrBlock:usr1";
+			gpios = <&gpio7 8 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "cpu0";
+			default-state = "off";
+		};
+
+		led2 {
+			label = "sndrBlock:usr2";
+			gpios = <&gpio7 14 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "mmc0";
+			default-state = "off";
+		};
+
+		led3 {
+			label = "sndrBlock:usr3";
+			gpios = <&gpio7 15 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "disk-activity";
+			default-state = "off";
+		};
+	};
+
+	gpio_fan: gpio_fan {
+		/* Based on 5v 500mA AFB02505HHB */
+		compatible = "gpio-fan";
+		gpios =  <&tps659038_gpio 2 GPIO_ACTIVE_HIGH>;
+		gpio-fan,speed-map = <0     0>,
+				     <13000 1>;
+		#cooling-cells = <2>;
+	};
+
+	hdmi0: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&tpd12s015_out>;
+			};
+		};
+	};
+
+	tpd12s015: encoder {
+		compatible = "ti,tpd12s015";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				tpd12s015_in: endpoint {
+					remote-endpoint = <&hdmi_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				tpd12s015_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+
+	sound0: sound0 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "BeagleBoard-X15";
+		simple-audio-card,widgets =
+			"Line", "Line Out",
+			"Line", "Line In";
+		simple-audio-card,routing =
+			"Line Out",	"LLOUT",
+			"Line Out",	"RLOUT",
+			"MIC2L",	"Line In",
+			"MIC2R",	"Line In";
+		simple-audio-card,format = "dsp_b";
+		simple-audio-card,bitclock-master = <&sound0_master>;
+		simple-audio-card,frame-master = <&sound0_master>;
+		simple-audio-card,bitclock-inversion;
+
+		simple-audio-card,cpu {
+			sound-dai = <&mcasp3>;
+		};
+
+		sound0_master: simple-audio-card,codec {
+			sound-dai = <&tlv320aic3104>;
+			clocks = <&clkout2_clk>;
+		};
+	};
+};
+
+&dra7_pmx_core {
+	mmc1_pins_default: mmc1_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x376c, PIN_INPUT | MUX_MODE14)	/* mmc1sdcd.gpio219 */
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_default: mmc2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+	tps659038: tps659038@58 {
+		compatible = "ti,tps659038";
+		reg = <0x58>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
+
+		#interrupt-cells = <2>;
+		interrupt-controller;
+
+		ti,system-power-controller;
+
+		tps659038_pmic {
+			compatible = "ti,tps659038-pmic";
+
+			regulators {
+				smps12_reg: smps12 {
+					/* VDD_MPU */
+					regulator-name = "smps12";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps3_reg: smps3 {
+					/* VDD_DDR */
+					regulator-name = "smps3";
+					regulator-min-microvolt = <1350000>;
+					regulator-max-microvolt = <1350000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps45_reg: smps45 {
+					/* VDD_DSPEVE, VDD_IVA, VDD_GPU */
+					regulator-name = "smps45";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				smps6_reg: smps6 {
+					/* VDD_CORE */
+					regulator-name = "smps6";
+					regulator-min-microvolt = <850000>;
+					regulator-max-microvolt = <1150000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				/* SMPS7 unused */
+
+				smps8_reg: smps8 {
+					/* VDD_1V8 */
+					regulator-name = "smps8";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				/* SMPS9 unused */
+
+				ldo1_reg: ldo1 {
+					/* VDD_SD / VDDSHV8  */
+					regulator-name = "ldo1";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-boot-on;
+					regulator-always-on;
+				};
+
+				ldo2_reg: ldo2 {
+					/* VDD_SHV5 */
+					regulator-name = "ldo2";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo3_reg: ldo3 {
+					/* VDDA_1V8_PHYA */
+					regulator-name = "ldo3";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo4_reg: ldo4 {
+					/* VDDA_1V8_PHYB */
+					regulator-name = "ldo4";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo9_reg: ldo9 {
+					/* VDD_RTC */
+					regulator-name = "ldo9";
+					regulator-min-microvolt = <1050000>;
+					regulator-max-microvolt = <1050000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldoln_reg: ldoln {
+					/* VDDA_1V8_PLL */
+					regulator-name = "ldoln";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldousb_reg: ldousb {
+					/* VDDA_3V_USB: VDDA_USBHS33 */
+					regulator-name = "ldousb";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-boot-on;
+				};
+
+				regen1: regen1 {
+					/* VDD_3V3_ON */
+					regulator-name = "regen1";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+			};
+		};
+
+		tps659038_rtc: tps659038_rtc {
+			compatible = "ti,palmas-rtc";
+			interrupt-parent = <&tps659038>;
+			interrupts = <8 IRQ_TYPE_EDGE_FALLING>;
+			wakeup-source;
+		};
+
+		tps659038_pwr_button: tps659038_pwr_button {
+			compatible = "ti,palmas-pwrbutton";
+			interrupt-parent = <&tps659038>;
+			interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
+			wakeup-source;
+			ti,palmas-long-press-seconds = <12>;
+		};
+
+		tps659038_gpio: tps659038_gpio {
+			compatible = "ti,palmas-gpio";
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		extcon_usb2: tps659038_usb {
+			compatible = "ti,palmas-usb-vid";
+			ti,enable-vbus-detection;
+			vbus-gpio = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+
+	tmp102: tmp102@48 {
+		compatible = "ti,tmp102";
+		reg = <0x48>;
+		interrupt-parent = <&gpio7>;
+		interrupts = <16 IRQ_TYPE_LEVEL_LOW>;
+		#thermal-sensor-cells = <1>;
+	};
+
+	tlv320aic3104: tlv320aic3104@18 {
+		#sound-dai-cells = <0>;
+		compatible = "ti,tlv320aic3104";
+		reg = <0x18>;
+		assigned-clocks = <&clkoutmux2_clk_mux>;
+		assigned-clock-parents = <&sys_clk2_dclk_div>;
+
+		status = "okay";
+		adc-settle-ms = <40>;
+
+		AVDD-supply = <&vdd_3v3>;
+		IOVDD-supply = <&vdd_3v3>;
+		DRVDD-supply = <&vdd_3v3>;
+		DVDD-supply = <&aic_dvdd>;
+	};
+
+	eeprom: eeprom@50 {
+		compatible = "at,24c32";
+		reg = <0x50>;
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+	mcp_rtc: rtc@6f {
+		compatible = "microchip,mcp7941x";
+		reg = <0x6f>;
+		interrupts-extended = <&crossbar_mpu GIC_SPI 2 IRQ_TYPE_EDGE_RISING>,
+				      <&dra7_pmx_core 0x424>;
+		interrupt-names = "irq", "wakeup";
+
+		vcc-supply = <&vdd_3v3>;
+		wakeup-source;
+	};
+};
+
+&gpio7 {
+	ti,no-reset-on-init;
+	ti,no-idle-on-init;
+};
+
+&cpu0 {
+	cpu0-supply = <&smps12_reg>;
+	voltage-tolerance = <1>;
+};
+
+&uart3 {
+	status = "okay";
+	interrupts-extended = <&crossbar_mpu GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+			      <&dra7_pmx_core 0x3f8>;
+};
+
+&mac {
+	status = "okay";
+	dual_emac;
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <1>;
+	phy-mode = "rgmii";
+	dual_emac_res_vlan = <1>;
+};
+
+&cpsw_emac1 {
+	phy_id = <&davinci_mdio>, <2>;
+	phy-mode = "rgmii";
+	dual_emac_res_vlan = <2>;
+};
+
+&mmc1 {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins_default>;
+
+	bus-width = <4>;
+	cd-gpios = <&gpio6 27 GPIO_ACTIVE_LOW>; /* gpio 219 */
+	/delete-property/ sd-uhs-sdr104;
+	/delete-property/ sd-uhs-sdr50;
+	/delete-property/ sd-uhs-ddr50;
+	/delete-property/ sd-uhs-sdr25;
+	/delete-property/ sd-uhs-sdr12;
+};
+
+&mmc2 {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_pins_default>;
+
+	vmmc-supply = <&vdd_3v3>;
+	bus-width = <8>;
+	ti,non-removable;
+	cap-mmc-dual-data-rate;
+	no-1-8-v;
+};
+
+&sata {
+	status = "okay";
+};
+
+&usb2_phy1 {
+	phy-supply = <&ldousb_reg>;
+};
+
+&usb2_phy2 {
+	phy-supply = <&ldousb_reg>;
+};
+
+&usb1 {
+	dr_mode = "host";
+};
+
+&omap_dwc3_2 {
+	extcon = <&extcon_usb2>;
+};
+
+&usb2 {
+	/*
+	 * Stand alone usage is peripheral only.
+	 * However, with some resistor modifications
+	 * this port can be used via expansion connectors
+	 * as "host" or "dual-role". If so, provide
+	 * the necessary dr_mode override in the expansion
+	 * board's DT.
+	 */
+	dr_mode = "peripheral";
+};
+
+&cpu_trips {
+	cpu_alert1: cpu_alert1 {
+		temperature = <50000>; /* millicelsius */
+		hysteresis = <2000>; /* millicelsius */
+		type = "active";
+	};
+};
+
+&cpu_cooling_maps {
+	map1 {
+		trip = <&cpu_alert1>;
+		cooling-device = <&gpio_fan THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+	};
+};
+
+&thermal_zones {
+	board_thermal: board_thermal {
+		polling-delay-passive = <1250>; /* milliseconds */
+		polling-delay = <1500>; /* milliseconds */
+
+				/* sensor       ID */
+		thermal-sensors = <&tmp102     0>;
+
+		board_trips: trips {
+			board_alert0: board_alert {
+				temperature = <40000>; /* millicelsius */
+				hysteresis = <2000>; /* millicelsius */
+				type = "active";
+			};
+
+			board_crit: board_crit {
+				temperature = <105000>; /* millicelsius */
+				hysteresis = <0>; /* millicelsius */
+				type = "critical";
+			};
+		};
+
+		board_cooling_maps: cooling-maps {
+			map0 {
+				trip = <&board_alert0>;
+				cooling-device =
+				  <&gpio_fan THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+       };
+};
+
+&dss {
+	status = "ok";
+
+	vdda_video-supply = <&ldoln_reg>;
+};
+
+&hdmi {
+	status = "ok";
+	vdda-supply = <&ldo4_reg>;
+
+	port {
+		hdmi_out: endpoint {
+			remote-endpoint = <&tpd12s015_in>;
+		};
+	};
+};
+
+&pcie1 {
+	gpios = <&gpio2 8 GPIO_ACTIVE_LOW>;
+};
+
+&mcasp3 {
+	#sound-dai-cells = <0>;
+	assigned-clocks = <&mcasp3_ahclkx_mux>;
+	assigned-clock-parents = <&sys_clkin2>;
+	status = "okay";
+
+	op-mode = <0>;	/* MCASP_IIS_MODE */
+	tdm-slots = <2>;
+	/* 4 serializers */
+	serial-dir = <	/* 0: INACTIVE, 1: TX, 2: RX */
+		1 2 0 0
+	>;
+	tx-num-evt = <32>;
+	rx-num-evt = <32>;
+};
+
+&mailbox5 {
+	status = "okay";
+	mbox_ipu1_ipc3x: mbox_ipu1_ipc3x {
+		status = "okay";
+	};
+	mbox_dsp1_ipc3x: mbox_dsp1_ipc3x {
+		status = "okay";
+	};
+};
+
+&mailbox6 {
+	status = "okay";
+	mbox_ipu2_ipc3x: mbox_ipu2_ipc3x {
+		status = "okay";
+	};
+};
diff --git a/arch/arm/dts/am571x-sndrblock.dts b/arch/arm/dts/am571x-sndrblock.dts
new file mode 100644
index 0000000000..3097086b1d
--- /dev/null
+++ b/arch/arm/dts/am571x-sndrblock.dts
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am571x-sndrblock-common.dtsi"
+
+/ {
+	model = "sndrBlock (Rev A)";
+};
+
+&tpd12s015 {
+	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
+		<&gpio6 28 GPIO_ACTIVE_HIGH>,	/* gpio6_28, LS OE */
+		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
+};
+
+&dra7_pmx_core {
+	mmc1_pins_hs: pinmux_mmc1_hs_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x3754, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_clk.clk */
+			DRA7XX_CORE_IOPAD(0x3758, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_cmd.cmd */
+			DRA7XX_CORE_IOPAD(0x375c, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat0.dat0 */
+			DRA7XX_CORE_IOPAD(0x3760, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat1.dat1 */
+			DRA7XX_CORE_IOPAD(0x3764, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat2.dat2 */
+			DRA7XX_CORE_IOPAD(0x3768, PIN_INPUT_PULLUP | MUX_VIRTUAL_MODE11 | MUX_MODE0) /* mmc1_dat3.dat3 */
+		>;
+	};
+
+	mmc2_pins_hs: mmc2_pins_hs {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+
+	mmc2_pins_ddr_3_3v: pinmux_mmc2_ddr_3_3v_pins {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x349c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a23.mmc2_clk */
+			DRA7XX_CORE_IOPAD(0x34b0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_cs1.mmc2_cmd */
+			DRA7XX_CORE_IOPAD(0x34a0, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a24.mmc2_dat0 */
+			DRA7XX_CORE_IOPAD(0x34a4, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a25.mmc2_dat1 */
+			DRA7XX_CORE_IOPAD(0x34a8, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a26.mmc2_dat2 */
+			DRA7XX_CORE_IOPAD(0x34ac, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a27.mmc2_dat3 */
+			DRA7XX_CORE_IOPAD(0x348c, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a19.mmc2_dat4 */
+			DRA7XX_CORE_IOPAD(0x3490, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a20.mmc2_dat5 */
+			DRA7XX_CORE_IOPAD(0x3494, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a21.mmc2_dat6 */
+			DRA7XX_CORE_IOPAD(0x3498, PIN_INPUT_PULLUP | MODE_SELECT | MUX_MODE1) /* gpmc_a22.mmc2_dat7 */
+		>;
+	};
+};
+
+&dra7_iodelay_core {
+	mmc2_iodelay_ddr_3_3v_conf: mmc2_iodelay_ddr_3_3v_conf {
+		pinctrl-pin-array = <
+			0x18c A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A19_IN */
+			0x190 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A19_OEN */
+			0x194 A_DELAY_PS(174) G_DELAY_PS(0)	/* CFG_GPMC_A19_OUT */
+			0x1a4 A_DELAY_PS(265) G_DELAY_PS(360)	/* CFG_GPMC_A20_IN */
+			0x1a8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A20_OEN */
+			0x1ac A_DELAY_PS(168) G_DELAY_PS(0)	/* CFG_GPMC_A20_OUT */
+			0x1b0 A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A21_IN */
+			0x1b4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A21_OEN */
+			0x1b8 A_DELAY_PS(136) G_DELAY_PS(0)	/* CFG_GPMC_A21_OUT */
+			0x1bc A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A22_IN */
+			0x1c0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OEN */
+			0x1c4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A22_OUT */
+			0x1c8 A_DELAY_PS(287) G_DELAY_PS(420)	/* CFG_GPMC_A23_IN */
+			0x1d0 A_DELAY_PS(879) G_DELAY_PS(0)	/* CFG_GPMC_A23_OUT */
+			0x1d4 A_DELAY_PS(144) G_DELAY_PS(240)	/* CFG_GPMC_A24_IN */
+			0x1d8 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OEN */
+			0x1dc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A24_OUT */
+			0x1e0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_IN */
+			0x1e4 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A25_OEN */
+			0x1e8 A_DELAY_PS(34) G_DELAY_PS(0)	/* CFG_GPMC_A25_OUT */
+			0x1ec A_DELAY_PS(0) G_DELAY_PS(120)	/* CFG_GPMC_A26_IN */
+			0x1f0 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A26_OEN */
+			0x1f4 A_DELAY_PS(120) G_DELAY_PS(0)	/* CFG_GPMC_A26_OUT */
+			0x1f8 A_DELAY_PS(120) G_DELAY_PS(180)	/* CFG_GPMC_A27_IN */
+			0x1fc A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OEN */
+			0x200 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_A27_OUT */
+			0x360 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_IN */
+			0x364 A_DELAY_PS(0) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OEN */
+			0x368 A_DELAY_PS(11) G_DELAY_PS(0)	/* CFG_GPMC_CS1_OUT */
+		>;
+	};
+};
+
+&mmc1 {
+	pinctrl-names = "default", "hs";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+
+	vmmc-supply = <&ldo1_reg>;
+	/delete-property/ sd-uhs-sdr104;
+	/delete-property/ sd-uhs-sdr50;
+	/delete-property/ sd-uhs-ddr50;
+	/delete-property/ sd-uhs-sdr25;
+	/delete-property/ sd-uhs-sdr12;
+};
+
+&mmc2 {
+	pinctrl-names = "default", "hs", "ddr_1_8v";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+	pinctrl-2 = <&mmc2_pins_ddr_3_3v &mmc2_iodelay_ddr_3_3v_conf>;
+	/delete-property/ mmc-hs200-1_8v;
+};
diff --git a/arch/arm/dts/am57xx-beagle-x15-revc.dts b/arch/arm/dts/am57xx-beagle-x15-revc.dts
new file mode 100644
index 0000000000..6a3b34259a
--- /dev/null
+++ b/arch/arm/dts/am57xx-beagle-x15-revc.dts
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am57xx-beagle-x15-common.dtsi"
+
+/ {
+	model = "TI AM5728 BeagleBoard-X15 rev C";
+};
+
+&tpd12s015 {
+	gpios = <&gpio7 10 GPIO_ACTIVE_HIGH>,	/* gpio7_10, CT CP HPD */
+		<&gpio2 30 GPIO_ACTIVE_HIGH>,	/* gpio2_30, LS OE */
+		<&gpio7 12 GPIO_ACTIVE_HIGH>;	/* gpio7_12/sp1_cs2, HPD */
+};
+
+&mmc1 {
+	vmmc-supply = <&vdd_3v3>;
+	vmmc_aux-supply = <&ldo1_reg>;
+};
diff --git a/board/ti/am57xx/board.c b/board/ti/am57xx/board.c
index 938725cf62..3a467fdb27 100644
--- a/board/ti/am57xx/board.c
+++ b/board/ti/am57xx/board.c
@@ -37,12 +37,30 @@
 #define board_is_x15()		board_ti_is("BBRDX15_")
 #define board_is_x15_revb1()	(board_ti_is("BBRDX15_") && \
 				 (strncmp("B.10", board_ti_get_rev(), 3) <= 0))
+#define board_is_x15_revc()	(board_ti_is("BBRDX15_") && \
+				 (strncmp("C.00", board_ti_get_rev(), 3) <= 0))
 #define board_is_am572x_evm()	board_ti_is("AM572PM_")
 #define board_is_am572x_evm_reva3()	\
 				(board_ti_is("AM572PM_") && \
 				 (strncmp("A.30", board_ti_get_rev(), 3) <= 0))
 #define board_is_am572x_idk()	board_ti_is("AM572IDK")
 #define board_is_am571x_idk()	board_ti_is("AM571IDK")
+#define board_is_am571x_sndrblock()	board_ti_is("AM571SBA")
+
+//Blank Flasher
+//#define board_is_x15_revb1_blank()	1
+//Normal
+#define board_is_x15_revb1_blank()	board_ti_is("XM57BLNK")
+
+//Blank Flasher
+//#define board_is_x15_revc_blank()	1
+//Normal
+#define board_is_x15_revc_blank()	board_ti_is("XM57BLNK")
+
+//Blank Flasher
+//#define board_is_am571x_blank()		1
+//Normal
+#define board_is_am571x_blank()		board_ti_is("XM57BLNK")
 
 #ifdef CONFIG_DRIVER_TI_CPSW
 #include <cpsw.h>
@@ -88,7 +106,7 @@ static const struct dmm_lisa_map_regs am571x_idk_lisa_regs = {
 
 void emif_get_dmm_regs(const struct dmm_lisa_map_regs **dmm_lisa_regs)
 {
-	if (board_is_am571x_idk())
+	if (board_is_am571x_idk() || board_is_am571x_sndrblock() || board_is_am571x_blank())
 		*dmm_lisa_regs = &am571x_idk_lisa_regs;
 	else
 		*dmm_lisa_regs = &beagle_x15_lisa_regs;
@@ -483,6 +501,14 @@ void do_board_detect(void)
 		bname = "AM572x IDK";
 	else if (board_is_am571x_idk())
 		bname = "AM571x IDK";
+	else if (board_is_am571x_sndrblock())
+		bname = "AM571x sndrblock";
+	else if (board_is_x15_revb1_blank())
+		bname = "BeagleBoard X15 blank";
+	else if (board_is_x15_revc_blank())
+		bname = "BeagleBoard X15 blank";
+	else if (board_is_am571x_blank())
+		bname = "AM571x sndrblock blank";
 
 	if (bname)
 		snprintf(sysinfo.board_string, SYSINFO_BOARD_NAME_MAX_LEN,
@@ -491,16 +517,18 @@ void do_board_detect(void)
 
 static void setup_board_eeprom_env(void)
 {
-	char *name = "beagle_x15";
+	char *name = "NULL";
 	int rc;
 
 	rc = ti_i2c_eeprom_am_get(CONFIG_EEPROM_BUS_ADDRESS,
 				  CONFIG_EEPROM_CHIP_ADDRESS);
 	if (rc)
-		goto invalid_eeprom;
+		printf("ti_i2c_eeprom_init failed %d\n", rc);
 
 	if (board_is_x15()) {
-		if (board_is_x15_revb1())
+		if (board_is_x15_revc())
+			name = "beagle_x15_revc";
+		else if (board_is_x15_revb1())
 			name = "beagle_x15_revb1";
 		else
 			name = "beagle_x15";
@@ -513,12 +541,20 @@ static void setup_board_eeprom_env(void)
 		name = "am572x_idk";
 	} else if (board_is_am571x_idk()) {
 		name = "am571x_idk";
-	} else {
-		printf("Unidentified board claims %s in eeprom header\n",
-		       board_ti_get_name());
+	} else if (board_is_am571x_sndrblock()) {
+		name = "am571x_sndrblock";
+	} else if (board_is_x15_revb1_blank()) {
+		name = "beagle_x15_revb1_blank";
+		setenv("board_eeprom_header", "beagle_x15_revb1_blank");
+	} else if (board_is_x15_revc_blank()) {
+		name = "beagle_x15_revc_blank";
+		setenv("board_eeprom_header", "beagle_x15_revc_blank");
+	} else if (board_is_am571x_blank()) {
+		name = "am571x_sndrblock_blank";
+		setenv("board_eeprom_header", "am571x_sndrblock_blank");
 	}
 
-invalid_eeprom:
+	printf("setup_board_eeprom_env: %s\n", name);
 	set_board_info_env(name);
 }
 
@@ -577,6 +613,15 @@ void am57x_idk_lcd_detect(void)
 	if (board_is_x15() || board_is_am572x_evm())
 		return;
 
+	if (board_is_x15_revb1_blank())
+		return;
+
+	if (board_is_x15_revc_blank())
+		return;
+
+	if (board_is_am571x_sndrblock() || board_is_am571x_blank())
+		return;
+
 	/* Only AM571x IDK has gpio control detect.. so check that */
 	if (board_is_am571x_idk() && !am571x_idk_needs_lcd())
 		goto out;
@@ -710,8 +755,8 @@ void recalibrate_iodelay(void)
 	do_set_mux32((*ctrl)->control_padconf_core_base, pconf, pconf_sz);
 
 	/* Now do the weird minor deltas that should be safe */
-	if (board_is_x15() || board_is_am572x_evm()) {
-		if (board_is_x15_revb1() || board_is_am572x_evm_reva3()) {
+	if (board_is_x15() || board_is_am572x_evm() || board_is_x15_revb1_blank() || board_is_x15_revc_blank()) {
+		if (board_is_x15_revb1() || board_is_am572x_evm_reva3() || board_is_x15_revb1_blank() || board_is_x15_revc_blank()) {
 			pconf = core_padconf_array_delta_x15_sr2_0;
 			pconf_sz = ARRAY_SIZE(core_padconf_array_delta_x15_sr2_0);
 		} else {
@@ -1120,12 +1165,17 @@ int ft_board_setup(void *blob, bd_t *bd)
 int board_fit_config_name_match(const char *name)
 {
 	if (board_is_x15()) {
-		if (board_is_x15_revb1()) {
+		if (board_is_x15_revc()) {
+			if (!strcmp(name, "am57xx-beagle-x15-revc"))
+				return 0;
+		} else if (board_is_x15_revb1()) {
 			if (!strcmp(name, "am57xx-beagle-x15-revb1"))
 				return 0;
 		} else if (!strcmp(name, "am57xx-beagle-x15")) {
 			return 0;
 		}
+	} else if (board_is_am571x_sndrblock() && !strcmp(name, "am571x-sndrblock")) {
+		return 0;
 	} else if (board_is_am572x_evm()) {
 		if (board_is_am572x_evm_reva3()) {
 			if (!strcmp(name, "am57xx-evm-reva3"))
@@ -1137,9 +1187,17 @@ int board_fit_config_name_match(const char *name)
 		return 0;
 	} else if (board_is_am571x_idk() && !strcmp(name, "am571x-idk")) {
 		return 0;
+	} else if (board_is_x15_revb1_blank() && !strcmp(name, "am57xx-beagle-x15-revb1")) {
+		return 0;
+	} else if (board_is_x15_revc_blank() && !strcmp(name, "am57xx-beagle-x15-revc")) {
+		return 0;
+	} else if (board_is_am571x_blank() && !strcmp(name, "am571x-sndrblock")) {
+		return 0;
 	}
 
-	return -1;
+//	return -1;
+//FIXME: for some reason, the board_is_am572x_evm_reva3 path is not returning..
+	return 0;
 }
 #endif
 
diff --git a/configs/am57xx_evm_defconfig b/configs/am57xx_evm_defconfig
index e32989d079..7e8a504b67 100644
--- a/configs/am57xx_evm_defconfig
+++ b/configs/am57xx_evm_defconfig
@@ -22,6 +22,10 @@ CONFIG_SPL_STACK_R=y
 CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SPL_DMA_SUPPORT=y
 CONFIG_SPL_OS_BOOT=y
+CONFIG_AUTOBOOT_KEYED=y
+CONFIG_AUTOBOOT_PROMPT="Press SPACE to abort autoboot in %d seconds\n"
+CONFIG_AUTOBOOT_DELAY_STR="d"
+CONFIG_AUTOBOOT_STOP_STR=" "
 CONFIG_HUSH_PARSER=y
 CONFIG_FASTBOOT=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
@@ -57,7 +61,7 @@ CONFIG_OF_CONTROL=y
 CONFIG_SPL_OF_CONTROL=y
 CONFIG_SPL_OF_TRANSLATE=y
 CONFIG_SPL_DM_SEQ_ALIAS=y
-CONFIG_OF_LIST="am57xx-beagle-x15 am57xx-beagle-x15-revb1 am57xx-evm-reva3 am572x-idk am571x-idk"
+CONFIG_OF_LIST="am57xx-beagle-x15 am57xx-beagle-x15-revb1 am57xx-beagle-x15-revc am571x-sndrblock am57xx-evm-reva3 am572x-idk am571x-idk"
 CONFIG_DM=y
 CONFIG_SPL_DM=y
 CONFIG_REGMAP=y
@@ -84,6 +88,8 @@ CONFIG_DM_SERIAL=y
 CONFIG_SYS_NS16550=y
 CONFIG_DM_SPI=y
 CONFIG_TI_QSPI=y
+CONFIG_OF_LIBFDT=y
+CONFIG_OF_LIBFDT_OVERLAY=y
 CONFIG_USB=y
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_XHCI_DWC3=y
diff --git a/include/configs/ti_armv7_common.h b/include/configs/ti_armv7_common.h
index 5c0e3cb487..7746f9be0e 100644
--- a/include/configs/ti_armv7_common.h
+++ b/include/configs/ti_armv7_common.h
@@ -112,6 +112,353 @@
 
 /* GPIO block */
 
+#define EEPROM_PROGRAMMING \
+	"eeprom_dump=i2c dev 0; " \
+		"i2c md 0x50 0x00.2 20; " \
+		"\0" \
+	"eeprom_blank=i2c dev 0; " \
+		"i2c mw 0x50 0x00.2 ff; " \
+		"i2c mw 0x50 0x01.2 ff; " \
+		"i2c mw 0x50 0x02.2 ff; " \
+		"i2c mw 0x50 0x03.2 ff; " \
+		"i2c mw 0x50 0x04.2 ff; " \
+		"i2c mw 0x50 0x05.2 ff; " \
+		"i2c mw 0x50 0x06.2 ff; " \
+		"i2c mw 0x50 0x07.2 ff; " \
+		"i2c mw 0x50 0x08.2 ff; " \
+		"i2c mw 0x50 0x09.2 ff; " \
+		"i2c mw 0x50 0x0a.2 ff; " \
+		"i2c mw 0x50 0x0b.2 ff; " \
+		"i2c mw 0x50 0x0c.2 ff; " \
+		"i2c mw 0x50 0x0d.2 ff; " \
+		"i2c mw 0x50 0x0e.2 ff; " \
+		"i2c mw 0x50 0x0f.2 ff; " \
+		"i2c mw 0x50 0x10.2 ff; " \
+		"i2c mw 0x50 0x11.2 ff; " \
+		"i2c mw 0x50 0x12.2 ff; " \
+		"i2c mw 0x50 0x13.2 ff; " \
+		"i2c mw 0x50 0x14.2 ff; " \
+		"i2c mw 0x50 0x15.2 ff; " \
+		"i2c mw 0x50 0x16.2 ff; " \
+		"i2c mw 0x50 0x17.2 ff; " \
+		"i2c mw 0x50 0x18.2 ff; " \
+		"i2c mw 0x50 0x19.2 ff; " \
+		"i2c mw 0x50 0x1a.2 ff; " \
+		"i2c mw 0x50 0x1b.2 ff; " \
+		"i2c mw 0x50 0x1c.2 ff; " \
+		"i2c mw 0x50 0x1d.2 ff; " \
+		"i2c mw 0x50 0x1e.2 ff; " \
+		"i2c mw 0x50 0x1f.2 ff; " \
+		"i2c md 0x50 0x00.2 20; " \
+		"\0" \
+	"eeprom_x15_b1=i2c dev 0; " \
+		"i2c mw 0x50 0x00.2 aa; " \
+		"i2c mw 0x50 0x01.2 55; " \
+		"i2c mw 0x50 0x02.2 33; " \
+		"i2c mw 0x50 0x03.2 ee; " \
+		"i2c mw 0x50 0x04.2 42; " \
+		"i2c mw 0x50 0x05.2 42; " \
+		"i2c mw 0x50 0x06.2 52; " \
+		"i2c mw 0x50 0x07.2 44; " \
+		"i2c mw 0x50 0x08.2 58; " \
+		"i2c mw 0x50 0x09.2 31; " \
+		"i2c mw 0x50 0x0a.2 35; " \
+		"i2c mw 0x50 0x0b.2 5f; " \
+		"i2c mw 0x50 0x0c.2 42; " \
+		"i2c mw 0x50 0x0d.2 2e; " \
+		"i2c mw 0x50 0x0e.2 31; " \
+		"i2c mw 0x50 0x0f.2 30; " \
+		"i2c mw 0x50 0x10.2 57; " \
+		"i2c mw 0x50 0x11.2 57; " \
+		"i2c mw 0x50 0x12.2 59; " \
+		"i2c mw 0x50 0x13.2 59; " \
+		"i2c mw 0x50 0x14.2 34; " \
+		"i2c mw 0x50 0x15.2 50; " \
+		"i2c mw 0x50 0x16.2 35; " \
+		"i2c mw 0x50 0x17.2 35; " \
+		"i2c mw 0x50 0x18.2 30; " \
+		"i2c mw 0x50 0x19.2 30; " \
+		"i2c mw 0x50 0x1a.2 30; " \
+		"i2c mw 0x50 0x1b.2 30; " \
+		"i2c mw 0x50 0x1c.2 ff; " \
+		"i2c mw 0x50 0x1d.2 ff; " \
+		"i2c mw 0x50 0x1e.2 ff; " \
+		"i2c mw 0x50 0x1f.2 ff; " \
+		"i2c md 0x50 0x00.2 20; " \
+		"\0" \
+	"eeprom_x15_c=i2c dev 0; " \
+		"i2c mw 0x50 0x00.2 aa; " \
+		"i2c mw 0x50 0x01.2 55; " \
+		"i2c mw 0x50 0x02.2 33; " \
+		"i2c mw 0x50 0x03.2 ee; " \
+		"i2c mw 0x50 0x04.2 42; " \
+		"i2c mw 0x50 0x05.2 42; " \
+		"i2c mw 0x50 0x06.2 52; " \
+		"i2c mw 0x50 0x07.2 44; " \
+		"i2c mw 0x50 0x08.2 58; " \
+		"i2c mw 0x50 0x09.2 31; " \
+		"i2c mw 0x50 0x0a.2 35; " \
+		"i2c mw 0x50 0x0b.2 5f; " \
+		"i2c mw 0x50 0x0c.2 43; " \
+		"i2c mw 0x50 0x0d.2 2e; " \
+		"i2c mw 0x50 0x0e.2 30; " \
+		"i2c mw 0x50 0x0f.2 30; " \
+		"i2c mw 0x50 0x10.2 79; " \
+		"i2c mw 0x50 0x11.2 79; " \
+		"i2c mw 0x50 0x12.2 77; " \
+		"i2c mw 0x50 0x13.2 77; " \
+		"i2c mw 0x50 0x14.2 50; " \
+		"i2c mw 0x50 0x15.2 58; " \
+		"i2c mw 0x50 0x16.2 31; " \
+		"i2c mw 0x50 0x17.2 35; " \
+		"i2c mw 0x50 0x18.2 6e; " \
+		"i2c mw 0x50 0x19.2 6e; " \
+		"i2c mw 0x50 0x1a.2 6e; " \
+		"i2c mw 0x50 0x1b.2 6e; " \
+		"i2c mw 0x50 0x1c.2 ff; " \
+		"i2c mw 0x50 0x1d.2 ff; " \
+		"i2c mw 0x50 0x1e.2 ff; " \
+		"i2c mw 0x50 0x1f.2 ff; " \
+		"i2c md 0x50 0x00.2 20; " \
+		"\0" \
+	"eeprom_sndrblock=i2c dev 0; " \
+		"i2c mw 0x50 0x00.2 aa; " \
+		"i2c mw 0x50 0x01.2 55; " \
+		"i2c mw 0x50 0x02.2 33; " \
+		"i2c mw 0x50 0x03.2 ee; " \
+		"i2c mw 0x50 0x04.2 41; " \
+		"i2c mw 0x50 0x05.2 4d; " \
+		"i2c mw 0x50 0x06.2 35; " \
+		"i2c mw 0x50 0x07.2 37; " \
+		"i2c mw 0x50 0x08.2 31; " \
+		"i2c mw 0x50 0x09.2 53; " \
+		"i2c mw 0x50 0x0a.2 42; " \
+		"i2c mw 0x50 0x0b.2 41; " \
+		"i2c mw 0x50 0x0c.2 ff; " \
+		"i2c mw 0x50 0x0d.2 ff; " \
+		"i2c mw 0x50 0x0e.2 ff; " \
+		"i2c mw 0x50 0x0f.2 ff; " \
+		"i2c mw 0x50 0x10.2 ff; " \
+		"i2c mw 0x50 0x11.2 ff; " \
+		"i2c mw 0x50 0x12.2 ff; " \
+		"i2c mw 0x50 0x13.2 ff; " \
+		"i2c mw 0x50 0x14.2 ff; " \
+		"i2c mw 0x50 0x15.2 ff; " \
+		"i2c mw 0x50 0x16.2 ff; " \
+		"i2c mw 0x50 0x17.2 ff; " \
+		"i2c mw 0x50 0x18.2 ff; " \
+		"i2c mw 0x50 0x19.2 ff; " \
+		"i2c mw 0x50 0x1a.2 ff; " \
+		"i2c mw 0x50 0x1b.2 ff; " \
+		"i2c mw 0x50 0x1c.2 ff; " \
+		"i2c mw 0x50 0x1d.2 ff; " \
+		"i2c mw 0x50 0x1e.2 ff; " \
+		"i2c mw 0x50 0x1f.2 ff; " \
+		"i2c md 0x50 0x00.2 20; " \
+		"\0" \
+
+#define EEWIKI_MMC_BOOT \
+	"mmc_boot=${interface} dev ${mmcdev}; " \
+		"if ${interface} rescan; then " \
+			"echo Scanning ${interface} device ${mmcdev};" \
+			"setenv bootpart ${mmcdev}:1; " \
+			"echo Checking for: /uEnv.txt ...;" \
+			"if test -e ${interface} ${bootpart} /uEnv.txt; then " \
+				"load ${interface} ${bootpart} ${loadaddr} /uEnv.txt;" \
+				"env import -t ${loadaddr} ${filesize};" \
+				"echo Loaded environment from /uEnv.txt;" \
+				"echo Checking if uenvcmd is set ...;" \
+				"if test -n ${uenvcmd}; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+			"fi; " \
+			"echo Checking for: /boot/uEnv.txt ...;" \
+			"for i in 1 2 3 4 5 6 7 ; do " \
+				"setenv mmcpart ${i};" \
+				"setenv bootpart ${mmcdev}:${mmcpart};" \
+				"if test -e ${interface} ${bootpart} /boot/uEnv.txt; then " \
+					"load ${interface} ${bootpart} ${loadaddr} /boot/uEnv.txt;" \
+					"env import -t ${loadaddr} ${filesize};" \
+					"echo Loaded environment from /boot/uEnv.txt;" \
+					"if test -n ${dtb}; then " \
+						"setenv fdtfile ${dtb};" \
+						"echo debug: [dtb=${fdtfile}] ...;" \
+					"fi;" \
+					"echo Checking if uname_r is set in /boot/uEnv.txt ...;" \
+					"if test -n ${uname_r}; then " \
+						"echo debug: [uname_r=${uname_r}] ...;" \
+						"setenv oldroot /dev/mmcblk${mmcdev}p${mmcpart};" \
+						"run uname_boot;" \
+					"fi;" \
+				"fi;" \
+			"done;" \
+		"fi;\0" \
+
+#define EEWIKI_SCSI_BOOT \
+	"scsi_boot=${interface} reset ; " \
+		"if ${interface} dev ${mmcdev}; then " \
+			"echo Scanning ${interface} device ${mmcdev};" \
+			"setenv bootpart ${mmcdev}:1; " \
+			"echo Checking for: /uEnv.txt ...;" \
+			"if test -e ${interface} ${bootpart} /uEnv.txt; then " \
+				"load ${interface} ${bootpart} ${loadaddr} /uEnv.txt;" \
+				"env import -t ${loadaddr} ${filesize};" \
+				"echo Loaded environment from /uEnv.txt;" \
+				"echo Checking if uenvcmd is set ...;" \
+				"if test -n ${uenvcmd}; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+			"fi; " \
+			"echo Checking for: /boot/uEnv.txt ...;" \
+			"for i in 1 2 3 4 ; do " \
+				"setenv mmcpart ${i};" \
+				"setenv bootpart ${mmcdev}:${mmcpart};" \
+				"if test -e ${interface} ${bootpart} /boot/uEnv.txt; then " \
+					"load ${interface} ${bootpart} ${loadaddr} /boot/uEnv.txt;" \
+					"env import -t ${loadaddr} ${filesize};" \
+					"echo Loaded environment from /boot/uEnv.txt;" \
+					"if test -n ${dtb}; then " \
+						"setenv fdtfile ${dtb};" \
+						"echo debug: [dtb=${fdtfile}] ...;" \
+					"fi;" \
+					"echo Checking if uname_r is set in /boot/uEnv.txt ...;" \
+					"if test -n ${uname_r}; then " \
+						"echo debug: [uname_r=${uname_r}] ...;" \
+						"setenv oldroot /dev/sda${mmcpart};" \
+						"run uname_boot;" \
+					"fi;" \
+				"fi;" \
+			"done;" \
+		"fi;\0" \
+
+#define EEWIKI_USB_BOOT \
+	"usb_boot=${interface} reset ; " \
+		"if ${interface} dev ${mmcdev}; then " \
+			"echo Scanning ${interface} device ${mmcdev};" \
+			"setenv bootpart ${mmcdev}:1; " \
+			"echo Checking for: /uEnv.txt ...;" \
+			"if test -e ${interface} ${bootpart} /uEnv.txt; then " \
+				"load ${interface} ${bootpart} ${loadaddr} /uEnv.txt;" \
+				"env import -t ${loadaddr} ${filesize};" \
+				"echo Loaded environment from /uEnv.txt;" \
+				"echo Checking if uenvcmd is set in /uEnv.txt ...;" \
+				"if test -n ${uenvcmd}; then " \
+					"echo Running uenvcmd ...;" \
+					"run uenvcmd;" \
+				"fi;" \
+			"fi; " \
+			"echo Checking for: /boot/uEnv.txt ...;" \
+			"for i in 1 2 3 4 ; do " \
+				"setenv mmcpart ${i};" \
+				"setenv bootpart ${mmcdev}:${mmcpart};" \
+				"if test -e ${interface} ${bootpart} /boot/uEnv.txt; then " \
+					"load ${interface} ${bootpart} ${loadaddr} /boot/uEnv.txt;" \
+					"env import -t ${loadaddr} ${filesize};" \
+					"echo Loaded environment from /boot/uEnv.txt;" \
+					"if test -n ${dtb}; then " \
+						"setenv fdtfile ${dtb};" \
+						"echo debug: [dtb=${fdtfile}] ...;" \
+					"fi;" \
+					"echo Checking if uname_r is set in /boot/uEnv.txt ...;" \
+					"if test -n ${uname_r}; then " \
+						"echo debug: [uname_r=${uname_r}] ...;" \
+						"setenv oldroot /dev/sda${mmcpart};" \
+						"run uname_boot;" \
+					"fi;" \
+				"fi;" \
+			"done;" \
+		"fi;\0" \
+
+#define EEWIKI_UNAME_BOOT \
+	"uname_boot="\
+		"setenv bootdir /boot; " \
+		"setenv bootfile vmlinuz-${uname_r}; " \
+		"if test -e ${interface} ${bootpart} ${bootdir}/${bootfile}; then " \
+			"echo loading ${bootdir}/${bootfile} ...; "\
+			"run loadimage;" \
+			"setenv fdtdir /boot/dtbs/${uname_r}; " \
+			"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+				"run loadfdt;" \
+			"else " \
+				"setenv fdtdir /usr/lib/linux-image-${uname_r}; " \
+				"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+					"run loadfdt;" \
+				"else " \
+					"setenv fdtdir /lib/firmware/${uname_r}/device-tree; " \
+					"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+						"run loadfdt;" \
+					"else " \
+						"setenv fdtdir /boot/dtb-${uname_r}; " \
+						"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+							"run loadfdt;" \
+						"else " \
+							"setenv fdtdir /boot/dtbs; " \
+							"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+								"run loadfdt;" \
+							"else " \
+								"setenv fdtdir /boot/dtb; " \
+								"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+									"run loadfdt;" \
+								"else " \
+									"setenv fdtdir /boot; " \
+									"if test -e ${interface} ${bootpart} ${fdtdir}/${fdtfile}; then " \
+										"run loadfdt;" \
+									"else " \
+										"echo; echo unable to find ${fdtfile} ...; echo booting legacy ...;"\
+										"run args_mmc;" \
+										"echo debug: [${bootargs}] ... ;" \
+										"echo debug: [bootz ${loadaddr}] ... ;" \
+										"bootz ${loadaddr}; " \
+									"fi;" \
+								"fi;" \
+							"fi;" \
+						"fi;" \
+					"fi;" \
+				"fi;" \
+			"fi; " \
+			"setenv rdfile initrd.img-${uname_r}; " \
+			"if test -e ${interface} ${bootpart} ${bootdir}/${rdfile}; then " \
+				"echo loading ${bootdir}/${rdfile} ...; "\
+				"run loadrd;" \
+				"if test -n ${netinstall_enable}; then " \
+					"run args_netinstall; run message;" \
+					"echo debug: [${bootargs}] ... ;" \
+					"echo debug: [bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}] ... ;" \
+					"bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}; " \
+				"fi;" \
+				"if test -n ${uenv_root}; then " \
+					"run args_uenv_root;" \
+					"echo debug: [${bootargs}] ... ;" \
+					"echo debug: [bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}] ... ;" \
+					"bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}; " \
+				"fi;" \
+				"if test -n ${uuid}; then " \
+					"run args_mmc_uuid;" \
+					"echo debug: [${bootargs}] ... ;" \
+					"echo debug: [bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}] ... ;" \
+					"bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}; " \
+				"else " \
+					"run args_mmc_old;" \
+					"echo debug: [${bootargs}] ... ;" \
+					"echo debug: [bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}] ... ;" \
+					"bootz ${loadaddr} ${rdaddr}:${rdsize} ${fdtaddr}; " \
+				"fi;" \
+			"else " \
+				"if test -n ${uenv_root}; then " \
+					"run args_uenv_root;" \
+					"echo debug: [${bootargs}] ... ;" \
+					"echo debug: [bootz ${loadaddr} - ${fdtaddr}] ... ;" \
+					"bootz ${loadaddr} - ${fdtaddr}; " \
+				"fi;" \
+				"run args_mmc_old;" \
+				"echo debug: [${bootargs}] ... ;" \
+				"echo debug: [bootz ${loadaddr} - ${fdtaddr}] ... ;" \
+				"bootz ${loadaddr} - ${fdtaddr}; " \
+			"fi;" \
+		"fi;\0" \
+
 /*
  * The following are general good-enough settings for U-Boot.  We set a
  * large malloc pool as we generally have a lot of DDR, and we opt for
diff --git a/include/configs/ti_omap5_common.h b/include/configs/ti_omap5_common.h
index 62f1518f6b..19c6e2083f 100644
--- a/include/configs/ti_omap5_common.h
+++ b/include/configs/ti_omap5_common.h
@@ -73,11 +73,19 @@
 	"bootpart=0:2\0" \
 	"bootdir=/boot\0" \
 	"bootfile=zImage\0" \
+	"board_eeprom_header=undefined\0" \
 	"usbtty=cdc_acm\0" \
 	"vram=16M\0" \
 	"partitions=" PARTS_DEFAULT "\0" \
 	"optargs=\0" \
 	"dofastboot=0\0" \
+	"read_board_eeprom="\
+		"if test $board_eeprom_header = beagle_x15_revb1_blank; then " \
+			"run eeprom_dump; run eeprom_x15_b1; reset; fi; " \
+		"if test $board_eeprom_header = beagle_x15_revc_blank; then " \
+			"run eeprom_dump; run eeprom_x15_c; reset; fi; " \
+		"if test $board_eeprom_header = am571x_sndrblock_blank; then " \
+			"run eeprom_dump; run eeprom_sndrblock; reset; fi;  \0" \
 	"findfdt="\
 		"if test $board_name = omap5_uevm; then " \
 			"setenv fdtfile omap5-uevm.dtb; fi; " \
@@ -93,6 +101,8 @@
 			"setenv fdtfile am57xx-beagle-x15.dtb; fi;" \
 		"if test $board_name = beagle_x15_revb1; then " \
 			"setenv fdtfile am57xx-beagle-x15-revb1.dtb; fi;" \
+		"if test $board_name = beagle_x15_revc; then " \
+			"setenv fdtfile am57xx-beagle-x15-revc.dtb; fi;" \
 		"if test $board_name = am572x_idk && test $idk_lcd = no; then " \
 			"setenv fdtfile am572x-idk.dtb; fi;" \
 		"if test $board_name = am572x_idk && test $idk_lcd = osd101t2045; then " \
@@ -109,28 +119,30 @@
 			"setenv fdtfile am571x-idk-lcd-osd101t2045.dtb; fi;" \
 		"if test $board_name = am571x_idk && test $idk_lcd = osd101t2587; then " \
 			"setenv fdtfile am571x-idk-lcd-osd101t2587.dtb; fi;" \
+		"if test $board_name = am571x_sndrblock; then " \
+			"setenv fdtfile am571x-sndrblock.dtb; fi;" \
 		"if test $fdtfile = undefined; then " \
 			"echo WARNING: Could not determine device tree to use; fi; \0" \
+	EEWIKI_USB_BOOT \
+	EEWIKI_SCSI_BOOT \
+	EEWIKI_MMC_BOOT \
+	EEWIKI_UNAME_BOOT \
+	EEPROM_PROGRAMMING \
 	DFUARGS \
 	NETARGS \
 
 #define CONFIG_BOOTCOMMAND \
-	"if test ${dofastboot} -eq 1; then " \
-		"echo Boot fastboot requested, resetting dofastboot ...;" \
-		"setenv dofastboot 0; saveenv;" \
-		"echo Booting into fastboot ...; " \
-		"fastboot " __stringify(CONFIG_FASTBOOT_USB_DEV) "; " \
-	"fi;" \
-	"if test ${boot_fit} -eq 1; then "	\
-		"run update_to_fit;"	\
-	"fi;"	\
+	"run read_board_eeprom; " \
 	"run findfdt; " \
-	"run envboot; " \
-	"run mmcboot;" \
+	"setenv mmcdev 0; " \
+	"setenv interface usb; " \
+	"echo usb_boot is currently disabled;" \
+	"setenv interface scsi; " \
+	"echo scsi_boot is currently disabled;" \
+	"setenv interface mmc; " \
+	"run mmc_boot;" \
 	"setenv mmcdev 1; " \
-	"setenv bootpart 1:2; " \
-	"setenv mmcroot /dev/mmcblk0p2 rw; " \
-	"run mmcboot;" \
+	"run mmc_boot;" \
 	""
 
 /*
diff --git a/include/environment/ti/mmc.h b/include/environment/ti/mmc.h
index b987f71516..86f94d81f6 100644
--- a/include/environment/ti/mmc.h
+++ b/include/environment/ti/mmc.h
@@ -9,22 +9,45 @@
 #define DEFAULT_MMC_TI_ARGS \
 	"mmcdev=0\0" \
 	"mmcrootfstype=ext4 rootwait\0" \
-	"finduuid=part uuid mmc ${bootpart} uuid\0" \
+	"finduuid=part uuid ${interface} ${bootpart} uuid\0" \
 	"args_mmc=run finduuid;setenv bootargs console=${console} " \
 		"${optargs} " \
-		"root=PARTUUID=${uuid} rw " \
-		"rootfstype=${mmcrootfstype}\0" \
-	"loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr\0" \
-	"bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+		"root=PARTUUID=${uuid} ro " \
+		"rootfstype=${mmcrootfstype} " \
+		"${cmdline}\0" \
+	"args_mmc_old=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${oldroot} ro " \
+		"rootfstype=${mmcrootfstype} " \
+		"${cmdline}\0" \
+	"args_mmc_uuid=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=UUID=${uuid} ro " \
+		"rootfstype=${mmcrootfstype} " \
+		"${cmdline}\0" \
+	"args_uenv_root=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${uenv_root} ro " \
+		"rootfstype=${mmcrootfstype} " \
+		"${musb} ${cmdline}\0" \
+	"args_netinstall=setenv bootargs ${netinstall_bootargs} " \
+		"${optargs} " \
+		"${cape_disable} " \
+		"${cape_enable} " \
+		"root=/dev/ram rw " \
+		"${cmdline}\0" \
+	"loadbootscript=load ${interface} ${mmcdev} ${loadaddr} boot.scr\0" \
+	"bootscript=echo Running bootscript from ${interface}${mmcdev} ...; " \
 		"source ${loadaddr}\0" \
 	"bootenvfile=uEnv.txt\0" \
-	"importbootenv=echo Importing environment from mmc${mmcdev} ...; " \
+	"importbootenv=echo Importing environment from ${interface}${mmcdev} ...; " \
 		"env import -t ${loadaddr} ${filesize}\0" \
-	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenvfile}\0" \
-	"loadimage=load ${devtype} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
-	"loadfdt=load ${devtype} ${bootpart} ${fdtaddr} ${bootdir}/${fdtfile}\0" \
-	"envboot=mmc dev ${mmcdev}; " \
-		"if mmc rescan; then " \
+	"loadbootenv=fatload ${interface} ${mmcdev} ${loadaddr} ${bootenvfile}\0" \
+	"loadimage=load ${interface} ${bootpart} ${loadaddr} ${bootdir}/${bootfile}\0" \
+	"loadrd=load ${interface} ${bootpart} ${rdaddr} ${bootdir}/${rdfile}; setenv rdsize ${filesize}\0" \
+	"loadfdt=echo loading ${fdtdir}/${fdtfile} ...;  load ${interface} ${bootpart} ${fdtaddr} ${fdtdir}/${fdtfile}\0" \
+	"envboot=${interface} dev ${mmcdev}; " \
+		"if ${interface} rescan; then " \
 			"echo SD/MMC found on device ${mmcdev};" \
 			"if run loadbootscript; then " \
 				"run bootscript;" \
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index 30e6e316ac..1b62aedb00 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -172,6 +172,11 @@ ld-version = $(shell $(LD) --version | $(srctree)/scripts/ld-version.sh)
 # Usage:  $(call ld-ifversion, -ge, 22252, y)
 ld-ifversion = $(shell [ $(ld-version) $(1) $(2) ] && echo $(3) || echo $(4))
 
+# dtc-option
+# Usage:  DTC_FLAGS += $(call dtc-option,-Wno-unit_address_vs_reg)
+dtc-option = $(call try-run,\
+	echo '/dts-v1/; / {};' | $(DTC) $(1),$(1),$(2))
+
 ######
 
 ###
diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn
index 6547e57357..7b2cffce52 100644
--- a/scripts/Makefile.extrawarn
+++ b/scripts/Makefile.extrawarn
@@ -57,4 +57,10 @@ ifeq ("$(strip $(warning))","")
 endif
 
 KBUILD_CFLAGS += $(warning)
+
+else
+
+# Disable noisy checks by default
+DTC_FLAGS += $(call dtc-option,-Wno-unit_address_vs_reg)
+
 endif
-- 
2.13.2

